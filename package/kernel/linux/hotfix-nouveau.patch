# --- T2-COPYRIGHT-BEGIN ---
# t2/package/*/linux/hotfix-nouveau.patch
# Copyright (C) 2025 The T2 SDE Project
# SPDX-License-Identifier: GPL-2.0 or patched project license
# --- T2-COPYRIGHT-END ---

Jul 25 15:29:40 t2 kernel: Hardware name: PowerMac11,2 PPC970MP 0x440101 PowerMac
...
Jul 25 15:29:40 t2 kernel: nouveau 0000:0a:00.0: drm: 0x14C5: Parsing digital output script table
Jul 25 15:29:40 t2 kernel: BUG: Unable to handle kernel data access on read at 0x00041520
Jul 25 15:29:40 t2 kernel: Faulting instruction address: 0xc0003d0001be0844
Jul 25 15:29:40 t2 kernel: Oops: Kernel access of bad area, sig: 11 [#1]
Jul 25 15:29:40 t2 kernel: BE PAGE_SIZE=4K MMU=Hash  SMP NR_CPUS=8 NUMA PowerMac
Jul 25 15:29:40 t2 kernel: Modules linked in: windfarm_cpufreq_clamp windfarm_smu_sensors windfarm_smu_controls windfarm_pm112 snd_aoa_codec_onyx snd_aoa_fabric_layout snd_aoa windfarm_pid jo
ydev evdev mousedev mac_hid apple_mfi_fastcharge rndis_host cdc_ether usbnet mii snd_aoa_i2sbus snd_aoa_soundbus snd_pcm snd_timer snd soundcore rack_meter windfarm_smu_sat windfarm_max6690_s
ensor nouveau(+) windfarm_lm75_sensor windfarm_core gpu_sched drm_gpuvm drm_exec drm_client_lib drm_ttm_helper ttm drm_display_helper drm_kms_helper drm drm_panel_orientation_quirks syscopyar
ea sysfillrect sysimgblt fb_sys_fops i2c_algo_bit backlight uio_pdrv_genirq uio uninorth_agp agpgart zram dm_mod dax ipv6 nfsv4 dns_resolver nfs lockd grace sunrpc offb cfbfillrect cfbimgblt
fb_io_fops cfbcopyarea fb font input_leds sr_mod cdrom sd_mod uas ata_generic hid_apple hid_generic usbhid hid usb_storage pata_macio sata_svw libata firewire_ohci scsi_mod firewire_core ohci
_pci crc_itu_t scsi_common ehci_pci ehci_hcd tg3 ohci_hcd libphy usbcore usb_common nls_base
Jul 25 15:29:40 t2 kernel:  led_class
Jul 25 15:29:40 t2 kernel: CPU: 0 UID: 0 PID: 245 Comm: (udev-worker) Not tainted 6.14.0-09584-g7d06015d936c #7 PREEMPTLAZY
Jul 25 15:29:40 t2 kernel: Hardware name: PowerMac11,2 PPC970MP 0x440101 PowerMac
Jul 25 15:29:40 t2 kernel: NIP:  c0003d0001be0844 LR: c0003d0001be0830 CTR: 0000000000000000
Jul 25 15:29:40 t2 kernel: REGS: c0000000053f70e0 TRAP: 0300   Not tainted  (6.14.0-09584-g7d06015d936c)
Jul 25 15:29:40 t2 kernel: MSR:  9000000000009032 <SF,HV,EE,ME,IR,DR,RI>  CR: 24222220  XER: 00000000
Jul 25 15:29:40 t2 kernel: DAR: 0000000000041520 DSISR: 40000000 IRQMASK: 0 \x0aGPR00: c0003d0001be0830 c0000000053f7380 c0003d0000911900 c000000007bc6800 \x0aGPR04: 0000000000000000 0000000000000000 c000000007bc6e70 0000000000000001 \x0aGPR08: 01f3040000000000 0000000000041520 0000000000000000 c0003d0000813958 \x0aGPR12: c000000000071a48 c000000000e28000 0000000000000020 0000000000000000 \x0aGPR16: 0000000000000000 0000000000f52630 0000000000000000 0000000000000000 \x0aGPR20: 0000000000000000 0000000000000000 0000000000000001 c0003d0000928528 \x0aGPR24: c0003d0000928598 0000000000000000 c000000007025480 c000000007025480 \x0aGPR28: c0000000010b4000 0000000000000000 c000000007bc1800 c000000007bc6800
Jul 25 15:29:40 t2 kernel: NIP [c0003d0001be0844] nv_crtc_destroy+0x44/0xd4 [nouveau]
Jul 25 15:29:40 t2 kernel: LR [c0003d0001be0830] nv_crtc_destroy+0x30/0xd4 [nouveau]
Jul 25 15:29:40 t2 kernel: Call Trace:
Jul 25 15:29:40 t2 kernel: [c0000000053f7380] [c0003d0001be0830] nv_crtc_destroy+0x30/0xd4 [nouveau] (unreliable)
Jul 25 15:29:40 t2 kernel: [c0000000053f73c0] [c0003d00007f7bf4] drm_mode_config_cleanup+0x27c/0x30c [drm]
Jul 25 15:29:40 t2 kernel: [c0000000053f7490] [c0003d0001bdea50] nouveau_display_create+0x1cc/0x550 [nouveau]
Jul 25 15:29:40 t2 kernel: [c0000000053f7500] [c0003d0001bcc29c] nouveau_drm_device_init+0x1c8/0x844 [nouveau]
Jul 25 15:29:40 t2 kernel: [c0000000053f75e0] [c0003d0001bcc9ec] nouveau_drm_probe+0xd4/0x1e0 [nouveau]
Jul 25 15:29:40 t2 kernel: [c0000000053f7670] [c000000000557d24] local_pci_probe+0x50/0xa8
Jul 25 15:29:40 t2 kernel: [c0000000053f76f0] [c000000000557fa8] pci_device_probe+0x22c/0x240
Jul 25 15:29:40 t2 kernel: [c0000000053f7760] [c0000000005fff3c] really_probe+0x188/0x31c
Jul 25 15:29:40 t2 kernel: [c0000000053f77e0] [c000000000600204] __driver_probe_device+0x134/0x13c
Jul 25 15:29:40 t2 kernel: [c0000000053f7860] [c0000000006002c0] driver_probe_device+0x3c/0xb4
Jul 25 15:29:40 t2 kernel: [c0000000053f78a0] [c000000000600534] __driver_attach+0x118/0x128
Jul 25 15:29:40 t2 kernel: [c0000000053f78e0] [c0000000005fe038] bus_for_each_dev+0xa8/0xf4
Jul 25 15:29:40 t2 kernel: [c0000000053f7950] [c0000000005ff460] driver_attach+0x2c/0x40
Jul 25 15:29:40 t2 kernel: [c0000000053f7970] [c0000000005fea68] bus_add_driver+0x130/0x278
Jul 25 15:29:40 t2 kernel: [c0000000053f7a00] [c00000000060117c] driver_register+0x9c/0x1a0
Jul 25 15:29:40 t2 kernel: [c0000000053f7a80] [c00000000055623c] __pci_register_driver+0x5c/0x70
Jul 25 15:29:40 t2 kernel: [c0000000053f7aa0] [c0003d0001c058a0] nouveau_drm_init+0x254/0x278 [nouveau]
Jul 25 15:29:40 t2 kernel: [c0000000053f7b10] [c00000000000e9bc] do_one_initcall+0x84/0x268
Jul 25 15:29:40 t2 kernel: [c0000000053f7bf0] [c0000000001a0ba0] do_init_module+0x70/0x2d8
Jul 25 15:29:40 t2 kernel: [c0000000053f7c70] [c0000000001a42bc] init_module_from_file+0xb4/0x108
Jul 25 15:29:40 t2 kernel: [c0000000053f7d50] [c0000000001a4504] sys_finit_module+0x1ac/0x478
Jul 25 15:29:40 t2 kernel: [c0000000053f7e10] [c000000000023230] system_call_exception+0x1a4/0x20c
Jul 25 15:29:40 t2 kernel: [c0000000053f7e50] [c00000000000c554] system_call_common+0xf4/0x258
Jul 25 15:29:40 t2 kernel: --- interrupt: c00 at 0xfd5f988
Jul 25 15:29:40 t2 kernel: NIP:  000000000fd5f988 LR: 000000000ff9b148 CTR: 0000000000000000
Jul 25 15:29:40 t2 kernel: REGS: c0000000053f7e80 TRAP: 0c00   Not tainted  (6.14.0-09584-g7d06015d936c)
Jul 25 15:29:40 t2 kernel: MSR:  100000000000d032 <HV,EE,PR,ME,IR,DR,RI>  CR: 28222244  XER: 00000000
Jul 25 15:29:40 t2 kernel: IRQMASK: 0 \x0aGPR00: 0000000000000161 00000000ffcdc2d0 00000000405db160 0000000000000020 \x0aGPR04: 000000000ffa2c9c 0000000000000000 000000000000001f 0000000000000045 \x0aGPR08: 0000000011a13770 0000000000000000 0000000000000000 0000000000000000 \x0aGPR12: 0000000000000000 0000000010249d8c 0000000000000020 0000000000000000 \x0aGPR16: 0000000000000000 0000000000f52630 0000000000000000 0000000000000000 \x0aGPR20: 0000000000000000 0000000000000000 0000000000000000 0000000011a11a70 \x0aGPR24: 0000000011a13580 0000000011a11950 0000000011a11a70 0000000000020000 \x0aGPR28: 000000000ffa2c9c 0000000000000000 000000000ffafc40 0000000011a11a70
Jul 25 15:29:40 t2 kernel: NIP [000000000fd5f988] 0xfd5f988
Jul 25 15:29:40 t2 kernel: LR [000000000ff9b148] 0xff9b148
Jul 25 15:29:40 t2 kernel: --- interrupt: c00
Jul 25 15:29:40 t2 kernel: Code: f821ffc1 418200ac e93f0000 e9290038 e9291468 eba90000 48026c0d e8410018 e93f06aa 3d290001 392982a4 79291f24 <7fdd482a> 2c3e0000 41820030 7fc3f378
Jul 25 15:29:40 t2 kernel: ---[ end trace 0000000000000000 ]---

commit a73583107af9b42c0a28045e4e30ec3fab2dbcd1
Author: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
Date:   Mon Jan 6 01:00:14 2025 +0200

    drm/nouveau: vendor in drm_encoder_slave API

    Nouveau driver is the only user of the drm_encoder_slave API. Rework
    necessary bits of drm_encoder_slave into the nouveau_i2c_encoder API and
    drop drm_encoder_slave.c from the DRM KMS helper.

diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index 85af94bb907d..19fb370fbc56 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -135,6 +135,7 @@ drm_kms_helper-y := \
 	drm_atomic_state_helper.o \
 	drm_crtc_helper.o \
 	drm_damage_helper.o \
+	drm_encoder_slave.o \
 	drm_flip_work.o \
 	drm_format_helper.o \
 	drm_gem_atomic_helper.o \
diff --git a/drivers/gpu/drm/nouveau/dispnv04/nouveau_i2c_encoder.c b/drivers/gpu/drm/drm_encoder_slave.c
similarity index 54%
rename from drivers/gpu/drm/nouveau/dispnv04/nouveau_i2c_encoder.c
rename to drivers/gpu/drm/drm_encoder_slave.c
index e2bf99c43336..e464429d32df 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/nouveau_i2c_encoder.c
+++ b/drivers/gpu/drm/drm_encoder_slave.c
@@ -26,10 +26,10 @@
 
 #include <linux/module.h>
 
-#include <dispnv04/i2c/encoder_i2c.h>
+#include <drm/drm_encoder_slave.h>
 
 /**
- * nouveau_i2c_encoder_init - Initialize an I2C slave encoder
+ * drm_i2c_encoder_init - Initialize an I2C slave encoder
  * @dev:	DRM device.
  * @encoder:    Encoder to be attached to the I2C device. You aren't
  *		required to have called drm_encoder_init() before.
@@ -40,7 +40,7 @@
  *
  * Create an I2C device on the specified bus (the module containing its
  * driver is transparently loaded) and attach it to the specified
- * &nouveau_i2c_encoder. The @encoder_i2c_funcs field will be initialized with
+ * &drm_encoder_slave. The @slave_funcs field will be initialized with
  * the hooks provided by the slave driver.
  *
  * If @info.platform_data is non-NULL it will be used as the initial
@@ -49,14 +49,14 @@
  * Returns 0 on success or a negative errno on failure, in particular,
  * -ENODEV is returned when no matching driver is found.
  */
-int nouveau_i2c_encoder_init(struct drm_device *dev,
-			     struct nouveau_i2c_encoder *encoder,
-			     struct i2c_adapter *adap,
-			     const struct i2c_board_info *info)
+int drm_i2c_encoder_init(struct drm_device *dev,
+			 struct drm_encoder_slave *encoder,
+			 struct i2c_adapter *adap,
+			 const struct i2c_board_info *info)
 {
 	struct module *module = NULL;
 	struct i2c_client *client;
-	struct nouveau_i2c_encoder_driver *encoder_drv;
+	struct drm_i2c_encoder_driver *encoder_drv;
 	int err = 0;
 
 	request_module("%s%s", I2C_MODULE_PREFIX, info->type);
@@ -73,16 +73,16 @@ int nouveau_i2c_encoder_init(struct drm_device *dev,
 		goto fail_unregister;
 	}
 
-	encoder->i2c_client = client;
+	encoder->bus_priv = client;
 
-	encoder_drv = to_nouveau_i2c_encoder_driver(to_i2c_driver(client->dev.driver));
+	encoder_drv = to_drm_i2c_encoder_driver(to_i2c_driver(client->dev.driver));
 
 	err = encoder_drv->encoder_init(client, dev, encoder);
 	if (err)
 		goto fail_module_put;
 
 	if (info->platform_data)
-		encoder->encoder_i2c_funcs->set_config(&encoder->base,
+		encoder->slave_funcs->set_config(&encoder->base,
 						 info->platform_data);
 
 	return 0;
@@ -93,53 +93,90 @@ int nouveau_i2c_encoder_init(struct drm_device *dev,
 	i2c_unregister_device(client);
 	return err;
 }
+EXPORT_SYMBOL(drm_i2c_encoder_init);
 
 /**
- * nouveau_i2c_encoder_destroy - Unregister the I2C device backing an encoder
+ * drm_i2c_encoder_destroy - Unregister the I2C device backing an encoder
  * @drm_encoder:	Encoder to be unregistered.
  *
  * This should be called from the @destroy method of an I2C slave
  * encoder driver once I2C access is no longer needed.
  */
-void nouveau_i2c_encoder_destroy(struct drm_encoder *drm_encoder)
+void drm_i2c_encoder_destroy(struct drm_encoder *drm_encoder)
 {
-	struct nouveau_i2c_encoder *encoder = to_encoder_i2c(drm_encoder);
-	struct i2c_client *client = nouveau_i2c_encoder_get_client(drm_encoder);
+	struct drm_encoder_slave *encoder = to_encoder_slave(drm_encoder);
+	struct i2c_client *client = drm_i2c_encoder_get_client(drm_encoder);
 	struct module *module = client->dev.driver->owner;
 
 	i2c_unregister_device(client);
-	encoder->i2c_client = NULL;
+	encoder->bus_priv = NULL;
 
 	module_put(module);
 }
-EXPORT_SYMBOL(nouveau_i2c_encoder_destroy);
+EXPORT_SYMBOL(drm_i2c_encoder_destroy);
 
 /*
  * Wrapper fxns which can be plugged in to drm_encoder_helper_funcs:
  */
 
-bool nouveau_i2c_encoder_mode_fixup(struct drm_encoder *encoder,
-				    const struct drm_display_mode *mode,
-				    struct drm_display_mode *adjusted_mode)
+static inline const struct drm_encoder_slave_funcs *
+get_slave_funcs(struct drm_encoder *enc)
 {
-	if (!get_encoder_i2c_funcs(encoder)->mode_fixup)
+	return to_encoder_slave(enc)->slave_funcs;
+}
+
+void drm_i2c_encoder_dpms(struct drm_encoder *encoder, int mode)
+{
+	get_slave_funcs(encoder)->dpms(encoder, mode);
+}
+EXPORT_SYMBOL(drm_i2c_encoder_dpms);
+
+bool drm_i2c_encoder_mode_fixup(struct drm_encoder *encoder,
+		const struct drm_display_mode *mode,
+		struct drm_display_mode *adjusted_mode)
+{
+	if (!get_slave_funcs(encoder)->mode_fixup)
 		return true;
 
-	return get_encoder_i2c_funcs(encoder)->mode_fixup(encoder, mode, adjusted_mode);
+	return get_slave_funcs(encoder)->mode_fixup(encoder, mode, adjusted_mode);
+}
+EXPORT_SYMBOL(drm_i2c_encoder_mode_fixup);
+
+void drm_i2c_encoder_prepare(struct drm_encoder *encoder)
+{
+	drm_i2c_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);
+}
+EXPORT_SYMBOL(drm_i2c_encoder_prepare);
+
+void drm_i2c_encoder_commit(struct drm_encoder *encoder)
+{
+	drm_i2c_encoder_dpms(encoder, DRM_MODE_DPMS_ON);
+}
+EXPORT_SYMBOL(drm_i2c_encoder_commit);
+
+void drm_i2c_encoder_mode_set(struct drm_encoder *encoder,
+		struct drm_display_mode *mode,
+		struct drm_display_mode *adjusted_mode)
+{
+	get_slave_funcs(encoder)->mode_set(encoder, mode, adjusted_mode);
 }
+EXPORT_SYMBOL(drm_i2c_encoder_mode_set);
 
-enum drm_connector_status nouveau_i2c_encoder_detect(struct drm_encoder *encoder,
-						     struct drm_connector *connector)
+enum drm_connector_status drm_i2c_encoder_detect(struct drm_encoder *encoder,
+	    struct drm_connector *connector)
 {
-	return get_encoder_i2c_funcs(encoder)->detect(encoder, connector);
+	return get_slave_funcs(encoder)->detect(encoder, connector);
 }
+EXPORT_SYMBOL(drm_i2c_encoder_detect);
 
-void nouveau_i2c_encoder_save(struct drm_encoder *encoder)
+void drm_i2c_encoder_save(struct drm_encoder *encoder)
 {
-	get_encoder_i2c_funcs(encoder)->save(encoder);
+	get_slave_funcs(encoder)->save(encoder);
 }
+EXPORT_SYMBOL(drm_i2c_encoder_save);
 
-void nouveau_i2c_encoder_restore(struct drm_encoder *encoder)
+void drm_i2c_encoder_restore(struct drm_encoder *encoder)
 {
-	get_encoder_i2c_funcs(encoder)->restore(encoder);
+	get_slave_funcs(encoder)->restore(encoder);
 }
+EXPORT_SYMBOL(drm_i2c_encoder_restore);
diff --git a/drivers/gpu/drm/nouveau/dispnv04/Kbuild b/drivers/gpu/drm/nouveau/dispnv04/Kbuild
index 4c7bc6bb81b3..949802882ebd 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/Kbuild
+++ b/drivers/gpu/drm/nouveau/dispnv04/Kbuild
@@ -6,7 +6,6 @@ nouveau-y += dispnv04/dac.o
 nouveau-y += dispnv04/dfp.o
 nouveau-y += dispnv04/disp.o
 nouveau-y += dispnv04/hw.o
-nouveau-y += dispnv04/nouveau_i2c_encoder.o
 nouveau-y += dispnv04/overlay.o
 nouveau-y += dispnv04/tvmodesnv17.o
 nouveau-y += dispnv04/tvnv04.o
diff --git a/drivers/gpu/drm/nouveau/dispnv04/dfp.c b/drivers/gpu/drm/nouveau/dispnv04/dfp.c
index c724bacc67f8..25fa41edcb3c 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/dfp.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/dfp.c
@@ -171,7 +171,7 @@ static struct drm_encoder *get_tmds_slave(struct drm_encoder *encoder)
 	list_for_each_entry(slave, &dev->mode_config.encoder_list, head) {
 		struct dcb_output *slave_dcb = nouveau_encoder(slave)->dcb;
 
-		if (slave_dcb->type == DCB_OUTPUT_TMDS && get_encoder_i2c_funcs(slave) &&
+		if (slave_dcb->type == DCB_OUTPUT_TMDS && get_slave_funcs(slave) &&
 		    slave_dcb->tmdsconf.slave_addr == dcb->tmdsconf.slave_addr)
 			return slave;
 	}
@@ -473,9 +473,8 @@ static void nv04_dfp_commit(struct drm_encoder *encoder)
 	/* Init external transmitters */
 	slave_encoder = get_tmds_slave(encoder);
 	if (slave_encoder)
-		get_encoder_i2c_funcs(slave_encoder)->mode_set(slave_encoder,
-							       &nv_encoder->mode,
-							       &nv_encoder->mode);
+		get_slave_funcs(slave_encoder)->mode_set(
+			slave_encoder, &nv_encoder->mode, &nv_encoder->mode);
 
 	helper->dpms(encoder, DRM_MODE_DPMS_ON);
 
@@ -615,8 +614,8 @@ static void nv04_dfp_destroy(struct drm_encoder *encoder)
 {
 	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
 
-	if (get_encoder_i2c_funcs(encoder))
-		get_encoder_i2c_funcs(encoder)->destroy(encoder);
+	if (get_slave_funcs(encoder))
+		get_slave_funcs(encoder)->destroy(encoder);
 
 	drm_encoder_cleanup(encoder);
 	kfree(nv_encoder);
@@ -650,8 +649,8 @@ static void nv04_tmds_slave_init(struct drm_encoder *encoder)
 	if (type < 0)
 		return;
 
-	nouveau_i2c_encoder_init(dev, to_encoder_i2c(encoder),
-				 &bus->i2c, &info[type].dev);
+	drm_i2c_encoder_init(dev, to_encoder_slave(encoder),
+			     &bus->i2c, &info[type].dev);
 }
 
 static const struct drm_encoder_helper_funcs nv04_lvds_helper_funcs = {
diff --git a/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_drv.c b/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_drv.c
index fd2150e07e36..db4f95020fae 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_drv.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_drv.c
@@ -47,14 +47,14 @@ static void ch7006_encoder_destroy(struct drm_encoder *encoder)
 	drm_property_destroy(encoder->dev, priv->scale_property);
 
 	kfree(priv);
-	to_encoder_i2c(encoder)->encoder_i2c_priv = NULL;
+	to_encoder_slave(encoder)->slave_priv = NULL;
 
-	nouveau_i2c_encoder_destroy(encoder);
+	drm_i2c_encoder_destroy(encoder);
 }
 
 static void  ch7006_encoder_dpms(struct drm_encoder *encoder, int mode)
 {
-	struct i2c_client *client = nouveau_i2c_encoder_get_client(encoder);
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
 	struct ch7006_priv *priv = to_ch7006_priv(encoder);
 	struct ch7006_state *state = &priv->state;
 
@@ -71,7 +71,7 @@ static void  ch7006_encoder_dpms(struct drm_encoder *encoder, int mode)
 
 static void ch7006_encoder_save(struct drm_encoder *encoder)
 {
-	struct i2c_client *client = nouveau_i2c_encoder_get_client(encoder);
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
 	struct ch7006_priv *priv = to_ch7006_priv(encoder);
 
 	ch7006_dbg(client, "\n");
@@ -81,7 +81,7 @@ static void ch7006_encoder_save(struct drm_encoder *encoder)
 
 static void ch7006_encoder_restore(struct drm_encoder *encoder)
 {
-	struct i2c_client *client = nouveau_i2c_encoder_get_client(encoder);
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
 	struct ch7006_priv *priv = to_ch7006_priv(encoder);
 
 	ch7006_dbg(client, "\n");
@@ -116,7 +116,7 @@ static void ch7006_encoder_mode_set(struct drm_encoder *encoder,
 				     struct drm_display_mode *drm_mode,
 				     struct drm_display_mode *adjusted_mode)
 {
-	struct i2c_client *client = nouveau_i2c_encoder_get_client(encoder);
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
 	struct ch7006_priv *priv = to_ch7006_priv(encoder);
 	struct ch7006_encoder_params *params = &priv->params;
 	struct ch7006_state *state = &priv->state;
@@ -179,7 +179,7 @@ static void ch7006_encoder_mode_set(struct drm_encoder *encoder,
 static enum drm_connector_status ch7006_encoder_detect(struct drm_encoder *encoder,
 						       struct drm_connector *connector)
 {
-	struct i2c_client *client = nouveau_i2c_encoder_get_client(encoder);
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
 	struct ch7006_priv *priv = to_ch7006_priv(encoder);
 	struct ch7006_state *state = &priv->state;
 	int det;
@@ -285,7 +285,7 @@ static int ch7006_encoder_set_property(struct drm_encoder *encoder,
 				       struct drm_property *property,
 				       uint64_t val)
 {
-	struct i2c_client *client = nouveau_i2c_encoder_get_client(encoder);
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
 	struct ch7006_priv *priv = to_ch7006_priv(encoder);
 	struct ch7006_state *state = &priv->state;
 	struct drm_mode_config *conf = &encoder->dev->mode_config;
@@ -370,7 +370,7 @@ static int ch7006_encoder_set_property(struct drm_encoder *encoder,
 	return 0;
 }
 
-static const struct nouveau_i2c_encoder_funcs ch7006_encoder_funcs = {
+static const struct drm_encoder_slave_funcs ch7006_encoder_funcs = {
 	.set_config = ch7006_encoder_set_config,
 	.destroy = ch7006_encoder_destroy,
 	.dpms = ch7006_encoder_dpms,
@@ -437,7 +437,7 @@ static int ch7006_resume(struct device *dev)
 
 static int ch7006_encoder_init(struct i2c_client *client,
 			       struct drm_device *dev,
-			       struct nouveau_i2c_encoder *encoder)
+			       struct drm_encoder_slave *encoder)
 {
 	struct ch7006_priv *priv;
 	int i;
@@ -448,8 +448,8 @@ static int ch7006_encoder_init(struct i2c_client *client,
 	if (!priv)
 		return -ENOMEM;
 
-	encoder->encoder_i2c_priv = priv;
-	encoder->encoder_i2c_funcs = &ch7006_encoder_funcs;
+	encoder->slave_priv = priv;
+	encoder->slave_funcs = &ch7006_encoder_funcs;
 
 	priv->norm = TV_NORM_PAL;
 	priv->select_subconnector = DRM_MODE_SUBCONNECTOR_Automatic;
@@ -495,7 +495,7 @@ static const struct dev_pm_ops ch7006_pm_ops = {
 	.resume = ch7006_resume,
 };
 
-static struct nouveau_i2c_encoder_driver ch7006_driver = {
+static struct drm_i2c_encoder_driver ch7006_driver = {
 	.i2c_driver = {
 		.probe = ch7006_probe,
 		.remove = ch7006_remove,
@@ -516,12 +516,12 @@ static struct nouveau_i2c_encoder_driver ch7006_driver = {
 
 static int __init ch7006_init(void)
 {
-	return i2c_add_driver(&ch7006_driver.i2c_driver);
+	return drm_i2c_encoder_register(THIS_MODULE, &ch7006_driver);
 }
 
 static void __exit ch7006_exit(void)
 {
-	i2c_del_driver(&ch7006_driver.i2c_driver);
+	drm_i2c_encoder_unregister(&ch7006_driver);
 }
 
 int ch7006_debug;
diff --git a/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_mode.c b/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_mode.c
index e58d94451959..6afe6d0ee630 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_mode.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_mode.c
@@ -198,7 +198,7 @@ const struct ch7006_mode *ch7006_lookup_mode(struct drm_encoder *encoder,
 
 void ch7006_setup_levels(struct drm_encoder *encoder)
 {
-	struct i2c_client *client = nouveau_i2c_encoder_get_client(encoder);
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
 	struct ch7006_priv *priv = to_ch7006_priv(encoder);
 	uint8_t *regs = priv->state.regs;
 	const struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];
@@ -229,7 +229,7 @@ void ch7006_setup_levels(struct drm_encoder *encoder)
 
 void ch7006_setup_subcarrier(struct drm_encoder *encoder)
 {
-	struct i2c_client *client = nouveau_i2c_encoder_get_client(encoder);
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
 	struct ch7006_priv *priv = to_ch7006_priv(encoder);
 	struct ch7006_state *state = &priv->state;
 	const struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];
@@ -253,7 +253,7 @@ void ch7006_setup_subcarrier(struct drm_encoder *encoder)
 
 void ch7006_setup_pll(struct drm_encoder *encoder)
 {
-	struct i2c_client *client = nouveau_i2c_encoder_get_client(encoder);
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
 	struct ch7006_priv *priv = to_ch7006_priv(encoder);
 	uint8_t *regs = priv->state.regs;
 	const struct ch7006_mode *mode = priv->mode;
@@ -324,7 +324,7 @@ void ch7006_setup_power_state(struct drm_encoder *encoder)
 
 void ch7006_setup_properties(struct drm_encoder *encoder)
 {
-	struct i2c_client *client = nouveau_i2c_encoder_get_client(encoder);
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
 	struct ch7006_priv *priv = to_ch7006_priv(encoder);
 	struct ch7006_state *state = &priv->state;
 	const struct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];
diff --git a/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_priv.h b/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_priv.h
index 5ad5157a2c02..d7a91e17510f 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_priv.h
+++ b/drivers/gpu/drm/nouveau/dispnv04/i2c/ch7006_priv.h
@@ -27,9 +27,9 @@
 #ifndef __NOUVEAU_I2C_CH7006_PRIV_H__
 #define __NOUVEAU_I2C_CH7006_PRIV_H__
 
+#include <drm/drm_encoder_slave.h>
 #include <drm/drm_probe_helper.h>
 
-#include <dispnv04/i2c/encoder_i2c.h>
 #include <dispnv04/i2c/ch7006.h>
 
 typedef int64_t fixed;
@@ -100,7 +100,7 @@ struct ch7006_priv {
 };
 
 #define to_ch7006_priv(x) \
-	((struct ch7006_priv *)to_encoder_i2c(x)->encoder_i2c_priv)
+	((struct ch7006_priv *)to_encoder_slave(x)->slave_priv)
 
 extern int ch7006_debug;
 extern char *ch7006_tv_norm;
diff --git a/drivers/gpu/drm/nouveau/dispnv04/i2c/sil164_drv.c b/drivers/gpu/drm/nouveau/dispnv04/i2c/sil164_drv.c
index 54ea8459332d..39b01c897518 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/i2c/sil164_drv.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/i2c/sil164_drv.c
@@ -27,10 +27,10 @@
 #include <linux/module.h>
 
 #include <drm/drm_drv.h>
+#include <drm/drm_encoder_slave.h>
 #include <drm/drm_print.h>
 #include <drm/drm_probe_helper.h>
 
-#include <dispnv04/i2c/encoder_i2c.h>
 #include <dispnv04/i2c/sil164.h>
 
 struct sil164_priv {
@@ -42,7 +42,7 @@ struct sil164_priv {
 };
 
 #define to_sil164_priv(x) \
-	((struct sil164_priv *)to_encoder_i2c(x)->encoder_i2c_priv)
+	((struct sil164_priv *)to_encoder_slave(x)->slave_priv)
 
 #define sil164_dbg(client, format, ...) do {				\
 		if (drm_debug_enabled(DRM_UT_KMS))			\
@@ -222,7 +222,7 @@ sil164_encoder_dpms(struct drm_encoder *encoder, int mode)
 	bool on = (mode == DRM_MODE_DPMS_ON);
 	bool duallink = (on && encoder->crtc->mode.clock > 165000);
 
-	sil164_set_power_state(nouveau_i2c_encoder_get_client(encoder), on);
+	sil164_set_power_state(drm_i2c_encoder_get_client(encoder), on);
 
 	if (priv->duallink_slave)
 		sil164_set_power_state(priv->duallink_slave, duallink);
@@ -233,7 +233,7 @@ sil164_encoder_save(struct drm_encoder *encoder)
 {
 	struct sil164_priv *priv = to_sil164_priv(encoder);
 
-	sil164_save_state(nouveau_i2c_encoder_get_client(encoder),
+	sil164_save_state(drm_i2c_encoder_get_client(encoder),
 			  priv->saved_state);
 
 	if (priv->duallink_slave)
@@ -246,7 +246,7 @@ sil164_encoder_restore(struct drm_encoder *encoder)
 {
 	struct sil164_priv *priv = to_sil164_priv(encoder);
 
-	sil164_restore_state(nouveau_i2c_encoder_get_client(encoder),
+	sil164_restore_state(drm_i2c_encoder_get_client(encoder),
 			     priv->saved_state);
 
 	if (priv->duallink_slave)
@@ -278,7 +278,7 @@ sil164_encoder_mode_set(struct drm_encoder *encoder,
 	struct sil164_priv *priv = to_sil164_priv(encoder);
 	bool duallink = adjusted_mode->clock > 165000;
 
-	sil164_init_state(nouveau_i2c_encoder_get_client(encoder),
+	sil164_init_state(drm_i2c_encoder_get_client(encoder),
 			  &priv->config, duallink);
 
 	if (priv->duallink_slave)
@@ -292,7 +292,7 @@ static enum drm_connector_status
 sil164_encoder_detect(struct drm_encoder *encoder,
 		      struct drm_connector *connector)
 {
-	struct i2c_client *client = nouveau_i2c_encoder_get_client(encoder);
+	struct i2c_client *client = drm_i2c_encoder_get_client(encoder);
 
 	if (sil164_read(client, SIL164_DETECT) & SIL164_DETECT_HOTPLUG_STAT)
 		return connector_status_connected;
@@ -331,10 +331,10 @@ sil164_encoder_destroy(struct drm_encoder *encoder)
 	i2c_unregister_device(priv->duallink_slave);
 
 	kfree(priv);
-	nouveau_i2c_encoder_destroy(encoder);
+	drm_i2c_encoder_destroy(encoder);
 }
 
-static const struct nouveau_i2c_encoder_funcs sil164_encoder_funcs = {
+static const struct drm_encoder_slave_funcs sil164_encoder_funcs = {
 	.set_config = sil164_encoder_set_config,
 	.destroy = sil164_encoder_destroy,
 	.dpms = sil164_encoder_dpms,
@@ -394,7 +394,7 @@ sil164_detect_slave(struct i2c_client *client)
 static int
 sil164_encoder_init(struct i2c_client *client,
 		    struct drm_device *dev,
-		    struct nouveau_i2c_encoder *encoder)
+		    struct drm_encoder_slave *encoder)
 {
 	struct sil164_priv *priv;
 	struct i2c_client *slave_client;
@@ -403,8 +403,8 @@ sil164_encoder_init(struct i2c_client *client,
 	if (!priv)
 		return -ENOMEM;
 
-	encoder->encoder_i2c_priv = priv;
-	encoder->encoder_i2c_funcs = &sil164_encoder_funcs;
+	encoder->slave_priv = priv;
+	encoder->slave_funcs = &sil164_encoder_funcs;
 
 	slave_client = sil164_detect_slave(client);
 	if (!IS_ERR(slave_client))
@@ -419,7 +419,7 @@ static const struct i2c_device_id sil164_ids[] = {
 };
 MODULE_DEVICE_TABLE(i2c, sil164_ids);
 
-static struct nouveau_i2c_encoder_driver sil164_driver = {
+static struct drm_i2c_encoder_driver sil164_driver = {
 	.i2c_driver = {
 		.probe = sil164_probe,
 		.driver = {
@@ -435,13 +435,13 @@ static struct nouveau_i2c_encoder_driver sil164_driver = {
 static int __init
 sil164_init(void)
 {
-	return i2c_add_driver(&sil164_driver.i2c_driver);
+	return drm_i2c_encoder_register(THIS_MODULE, &sil164_driver);
 }
 
 static void __exit
 sil164_exit(void)
 {
-	i2c_del_driver(&sil164_driver.i2c_driver);
+	drm_i2c_encoder_unregister(&sil164_driver);
 }
 
 MODULE_AUTHOR("Francisco Jerez <currojerez@riseup.net>");
diff --git a/drivers/gpu/drm/nouveau/dispnv04/tvnv04.c b/drivers/gpu/drm/nouveau/dispnv04/tvnv04.c
index c61ab083f62e..4ffd8af6bf8b 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/tvnv04.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/tvnv04.c
@@ -99,7 +99,7 @@ static void nv04_tv_dpms(struct drm_encoder *encoder, int mode)
 
 	NVWriteRAMDAC(dev, 0, NV_PRAMDAC_PLL_COEFF_SELECT, state->pllsel);
 
-	get_encoder_i2c_funcs(encoder)->dpms(encoder, mode);
+	get_slave_funcs(encoder)->dpms(encoder, mode);
 }
 
 static void nv04_tv_bind(struct drm_device *dev, int head, bool bind)
@@ -158,7 +158,7 @@ static void nv04_tv_mode_set(struct drm_encoder *encoder,
 	regp->tv_vskew = 1;
 	regp->tv_vsync_delay = 1;
 
-	get_encoder_i2c_funcs(encoder)->mode_set(encoder, mode, adjusted_mode);
+	get_slave_funcs(encoder)->mode_set(encoder, mode, adjusted_mode);
 }
 
 static void nv04_tv_commit(struct drm_encoder *encoder)
@@ -178,7 +178,7 @@ static void nv04_tv_commit(struct drm_encoder *encoder)
 
 static void nv04_tv_destroy(struct drm_encoder *encoder)
 {
-	get_encoder_i2c_funcs(encoder)->destroy(encoder);
+	get_slave_funcs(encoder)->destroy(encoder);
 	drm_encoder_cleanup(encoder);
 
 	kfree(encoder->helper_private);
@@ -191,11 +191,11 @@ static const struct drm_encoder_funcs nv04_tv_funcs = {
 
 static const struct drm_encoder_helper_funcs nv04_tv_helper_funcs = {
 	.dpms = nv04_tv_dpms,
-	.mode_fixup = nouveau_i2c_encoder_mode_fixup,
+	.mode_fixup = drm_i2c_encoder_mode_fixup,
 	.prepare = nv04_tv_prepare,
 	.commit = nv04_tv_commit,
 	.mode_set = nv04_tv_mode_set,
-	.detect = nouveau_i2c_encoder_detect,
+	.detect = drm_i2c_encoder_detect,
 };
 
 int
@@ -226,8 +226,8 @@ nv04_tv_create(struct drm_connector *connector, struct dcb_output *entry)
 			 NULL);
 	drm_encoder_helper_add(encoder, &nv04_tv_helper_funcs);
 
-	nv_encoder->enc_save = nouveau_i2c_encoder_save;
-	nv_encoder->enc_restore = nouveau_i2c_encoder_restore;
+	nv_encoder->enc_save = drm_i2c_encoder_save;
+	nv_encoder->enc_restore = drm_i2c_encoder_restore;
 
 	encoder->possible_crtcs = entry->heads;
 	encoder->possible_clones = 0;
@@ -235,14 +235,14 @@ nv04_tv_create(struct drm_connector *connector, struct dcb_output *entry)
 	nv_encoder->or = ffs(entry->or) - 1;
 
 	/* Run the slave-specific initialization */
-	ret = nouveau_i2c_encoder_init(dev, to_encoder_i2c(encoder),
-				       &bus->i2c,
-				       &nv04_tv_encoder_info[type].dev);
+	ret = drm_i2c_encoder_init(dev, to_encoder_slave(encoder),
+				   &bus->i2c,
+				   &nv04_tv_encoder_info[type].dev);
 	if (ret < 0)
 		goto fail_cleanup;
 
 	/* Attach it to the specified connector. */
-	get_encoder_i2c_funcs(encoder)->create_resources(encoder, connector);
+	get_slave_funcs(encoder)->create_resources(encoder, connector);
 	drm_connector_attach_encoder(connector, encoder);
 
 	return 0;
diff --git a/drivers/gpu/drm/nouveau/dispnv04/tvnv17.c b/drivers/gpu/drm/nouveau/dispnv04/tvnv17.c
index 06de05fe5db6..35ad4e10d273 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/tvnv17.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/tvnv17.c
@@ -779,7 +779,7 @@ static const struct drm_encoder_helper_funcs nv17_tv_helper_funcs = {
 	.detect = nv17_tv_detect,
 };
 
-static const struct nouveau_i2c_encoder_funcs nv17_tv_encoder_i2c_funcs = {
+static const struct drm_encoder_slave_funcs nv17_tv_slave_funcs = {
 	.get_modes = nv17_tv_get_modes,
 	.mode_valid = nv17_tv_mode_valid,
 	.create_resources = nv17_tv_create_resources,
@@ -818,7 +818,7 @@ nv17_tv_create(struct drm_connector *connector, struct dcb_output *entry)
 	drm_encoder_init(dev, encoder, &nv17_tv_funcs, DRM_MODE_ENCODER_TVDAC,
 			 NULL);
 	drm_encoder_helper_add(encoder, &nv17_tv_helper_funcs);
-	to_encoder_i2c(encoder)->encoder_i2c_funcs = &nv17_tv_encoder_i2c_funcs;
+	to_encoder_slave(encoder)->slave_funcs = &nv17_tv_slave_funcs;
 
 	tv_enc->base.enc_save = nv17_tv_save;
 	tv_enc->base.enc_restore = nv17_tv_restore;
diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.c b/drivers/gpu/drm/nouveau/nouveau_connector.c
index 6fb9719d721f..2d26784bde74 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.c
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.c
@@ -797,10 +797,8 @@ nouveau_connector_set_property(struct drm_connector *connector,
 						    property, value);
 	if (ret) {
 		if (nv_encoder && nv_encoder->dcb->type == DCB_OUTPUT_TV)
-			return get_encoder_i2c_funcs(encoder)->set_property(encoder,
-									    connector,
-									    property,
-									    value);
+			return get_slave_funcs(encoder)->set_property(
+				encoder, connector, property, value);
 		return ret;
 	}
 
@@ -1017,7 +1015,7 @@ nouveau_connector_get_modes(struct drm_connector *connector)
 		nouveau_connector_detect_depth(connector);
 
 	if (nv_encoder->dcb->type == DCB_OUTPUT_TV)
-		ret = get_encoder_i2c_funcs(encoder)->get_modes(encoder, connector);
+		ret = get_slave_funcs(encoder)->get_modes(encoder, connector);
 
 	if (nv_connector->type == DCB_CONNECTOR_LVDS ||
 	    nv_connector->type == DCB_CONNECTOR_LVDS_SPWG ||
@@ -1102,7 +1100,7 @@ nouveau_connector_mode_valid(struct drm_connector *connector,
 			max_clock = 350000;
 		break;
 	case DCB_OUTPUT_TV:
-		return get_encoder_i2c_funcs(encoder)->mode_valid(encoder, mode);
+		return get_slave_funcs(encoder)->mode_valid(encoder, mode);
 	case DCB_OUTPUT_DP:
 		return nv50_dp_mode_valid(nv_encoder, mode, NULL);
 	default:
diff --git a/drivers/gpu/drm/nouveau/nouveau_encoder.h b/drivers/gpu/drm/nouveau/nouveau_encoder.h
index dce8e5d9d496..333042fc493f 100644
--- a/drivers/gpu/drm/nouveau/nouveau_encoder.h
+++ b/drivers/gpu/drm/nouveau/nouveau_encoder.h
@@ -31,8 +31,7 @@
 
 #include <drm/display/drm_dp_helper.h>
 #include <drm/display/drm_dp_mst_helper.h>
-
-#include <dispnv04/i2c/encoder_i2c.h>
+#include <drm/drm_encoder_slave.h>
 
 #include "dispnv04/disp.h"
 
@@ -44,7 +43,7 @@ struct nouveau_connector;
 struct nvkm_i2c_port;
 
 struct nouveau_encoder {
-	struct nouveau_i2c_encoder base;
+	struct drm_encoder_slave base;
 
 	struct dcb_output *dcb;
 	struct nvif_outp outp;
@@ -138,7 +137,7 @@ find_encoder(struct drm_connector *connector, int type);
 
 static inline struct nouveau_encoder *nouveau_encoder(struct drm_encoder *enc)
 {
-	struct nouveau_i2c_encoder *slave = to_encoder_i2c(enc);
+	struct drm_encoder_slave *slave = to_encoder_slave(enc);
 
 	return container_of(slave, struct nouveau_encoder, base);
 }
@@ -148,6 +147,12 @@ static inline struct drm_encoder *to_drm_encoder(struct nouveau_encoder *enc)
 	return &enc->base.base;
 }
 
+static inline const struct drm_encoder_slave_funcs *
+get_slave_funcs(struct drm_encoder *enc)
+{
+	return to_encoder_slave(enc)->slave_funcs;
+}
+
 /* nouveau_dp.c */
 enum nouveau_dp_status {
 	NOUVEAU_DP_NONE,
diff --git a/drivers/gpu/drm/nouveau/include/dispnv04/i2c/encoder_i2c.h b/include/drm/drm_encoder_slave.h
similarity index 59%
rename from drivers/gpu/drm/nouveau/include/dispnv04/i2c/encoder_i2c.h
rename to include/drm/drm_encoder_slave.h
index 31334aa90781..b526643833dc 100644
--- a/drivers/gpu/drm/nouveau/include/dispnv04/i2c/encoder_i2c.h
+++ b/include/drm/drm_encoder_slave.h
@@ -24,8 +24,8 @@
  *
  */
 
-#ifndef __NOUVEAU_ENCODER_I2C_H__
-#define __NOUVEAU_ENCODER_I2C_H__
+#ifndef __DRM_ENCODER_SLAVE_H__
+#define __DRM_ENCODER_SLAVE_H__
 
 #include <linux/i2c.h>
 
@@ -33,7 +33,7 @@
 #include <drm/drm_encoder.h>
 
 /**
- * struct nouveau_i2c_encoder_funcs - Entry points exposed by a I2C encoder driver
+ * struct drm_encoder_slave_funcs - Entry points exposed by a slave encoder driver
  *
  * Most of its members are analogous to the function pointers in
  * &drm_encoder_helper_funcs and they can optionally be used to
@@ -41,7 +41,7 @@
  * @set_property) will typically be wrapped around and only be called
  * if the encoder is the currently selected one for the connector.
  */
-struct nouveau_i2c_encoder_funcs {
+struct drm_encoder_slave_funcs {
 	/**
 	 * @set_config: Initialize any encoder-specific modesetting parameters.
 	 * The meaning of the @params parameter is implementation dependent. It
@@ -58,23 +58,24 @@ struct nouveau_i2c_encoder_funcs {
 	void (*destroy)(struct drm_encoder *encoder);
 
 	/**
-	 * @dpms: Analogous to &drm_encoder_helper_funcs @dpms callback.
+	 * @dpms: Analogous to &drm_encoder_helper_funcs @dpms callback. Wrapped
+	 * by drm_i2c_encoder_dpms().
 	 */
 	void (*dpms)(struct drm_encoder *encoder, int mode);
 
 	/**
-	 * @save: Save state. Wrapped by nouveau_i2c_encoder_save().
+	 * @save: Save state. Wrapped by drm_i2c_encoder_save().
 	 */
 	void (*save)(struct drm_encoder *encoder);
 
 	/**
-	 * @restore: Restore state. Wrapped by nouveau_i2c_encoder_restore().
+	 * @restore: Restore state. Wrapped by drm_i2c_encoder_restore().
 	 */
 	void (*restore)(struct drm_encoder *encoder);
 
 	/**
 	 * @mode_fixup: Analogous to &drm_encoder_helper_funcs @mode_fixup
-	 * callback. Wrapped by nouveau_i2c_encoder_mode_fixup().
+	 * callback. Wrapped by drm_i2c_encoder_mode_fixup().
 	 */
 	bool (*mode_fixup)(struct drm_encoder *encoder,
 			   const struct drm_display_mode *mode,
@@ -87,7 +88,7 @@ struct nouveau_i2c_encoder_funcs {
 			  const struct drm_display_mode *mode);
 	/**
 	 * @mode_set: Analogous to &drm_encoder_helper_funcs @mode_set
-	 * callback.
+	 * callback. Wrapped by drm_i2c_encoder_mode_set().
 	 */
 	void (*mode_set)(struct drm_encoder *encoder,
 			 struct drm_display_mode *mode,
@@ -95,7 +96,7 @@ struct nouveau_i2c_encoder_funcs {
 
 	/**
 	 * @detect: Analogous to &drm_encoder_helper_funcs @detect
-	 * callback. Wrapped by nouveau_i2c_encoder_detect().
+	 * callback. Wrapped by drm_i2c_encoder_detect().
 	 */
 	enum drm_connector_status (*detect)(struct drm_encoder *encoder,
 					    struct drm_connector *connector);
@@ -119,60 +120,54 @@ struct nouveau_i2c_encoder_funcs {
 };
 
 /**
- * struct nouveau_i2c_encoder - I2C encoder struct
+ * struct drm_encoder_slave - Slave encoder struct
  *
- * A &nouveau_i2c_encoder has two sets of callbacks, @encoder_i2c_funcs and the
+ * A &drm_encoder_slave has two sets of callbacks, @slave_funcs and the
  * ones in @base. The former are never actually called by the common
  * CRTC code, it's just a convenience for splitting the encoder
  * functions in an upper, GPU-specific layer and a (hopefully)
  * GPU-agnostic lower layer: It's the GPU driver responsibility to
- * call the nouveau_i2c_encoder methods when appropriate.
+ * call the slave methods when appropriate.
  *
- * nouveau_i2c_encoder_init() provides a way to get an implementation of
+ * drm_i2c_encoder_init() provides a way to get an implementation of
  * this.
  */
-struct nouveau_i2c_encoder {
+struct drm_encoder_slave {
 	/**
 	 * @base: DRM encoder object.
 	 */
 	struct drm_encoder base;
 
 	/**
-	 * @encoder_i2c_funcs: I2C encoder callbacks.
+	 * @slave_funcs: Slave encoder callbacks.
 	 */
-	const struct nouveau_i2c_encoder_funcs *encoder_i2c_funcs;
+	const struct drm_encoder_slave_funcs *slave_funcs;
 
 	/**
-	 * @encoder_i2c_priv: I2C encoder private data.
+	 * @slave_priv: Slave encoder private data.
 	 */
-	void *encoder_i2c_priv;
+	void *slave_priv;
 
 	/**
-	 * @i2c_client: corresponding I2C client structure
+	 * @bus_priv: Bus specific data.
 	 */
-	struct i2c_client *i2c_client;
+	void *bus_priv;
 };
+#define to_encoder_slave(x) container_of((x), struct drm_encoder_slave, base)
 
-#define to_encoder_i2c(x) container_of((x), struct nouveau_i2c_encoder, base)
+int drm_i2c_encoder_init(struct drm_device *dev,
+			 struct drm_encoder_slave *encoder,
+			 struct i2c_adapter *adap,
+			 const struct i2c_board_info *info);
 
-int nouveau_i2c_encoder_init(struct drm_device *dev,
-			     struct nouveau_i2c_encoder *encoder,
-			     struct i2c_adapter *adap,
-			     const struct i2c_board_info *info);
-
-static inline const struct nouveau_i2c_encoder_funcs *
-get_encoder_i2c_funcs(struct drm_encoder *enc)
-{
-	return to_encoder_i2c(enc)->encoder_i2c_funcs;
-}
 
 /**
- * struct nouveau_i2c_encoder_driver
+ * struct drm_i2c_encoder_driver
  *
  * Describes a device driver for an encoder connected to the GPU through an I2C
  * bus.
  */
-struct nouveau_i2c_encoder_driver {
+struct drm_i2c_encoder_driver {
 	/**
 	 * @i2c_driver: I2C device driver description.
 	 */
@@ -180,41 +175,67 @@ struct nouveau_i2c_encoder_driver {
 
 	/**
 	 * @encoder_init: Callback to allocate any per-encoder data structures
-	 * and to initialize the @encoder_i2c_funcs and (optionally) @encoder_i2c_priv
+	 * and to initialize the @slave_funcs and (optionally) @slave_priv
 	 * members of @encoder.
 	 */
 	int (*encoder_init)(struct i2c_client *client,
 			    struct drm_device *dev,
-			    struct nouveau_i2c_encoder *encoder);
+			    struct drm_encoder_slave *encoder);
 
 };
-
-#define to_nouveau_i2c_encoder_driver(x) container_of((x),			\
-						  struct nouveau_i2c_encoder_driver, \
+#define to_drm_i2c_encoder_driver(x) container_of((x),			\
+						  struct drm_i2c_encoder_driver, \
 						  i2c_driver)
 
 /**
- * nouveau_i2c_encoder_get_client - Get the I2C client corresponding to an encoder
+ * drm_i2c_encoder_get_client - Get the I2C client corresponding to an encoder
  * @encoder: The encoder
  */
-static inline struct i2c_client *nouveau_i2c_encoder_get_client(struct drm_encoder *encoder)
+static inline struct i2c_client *drm_i2c_encoder_get_client(struct drm_encoder *encoder)
 {
-	return to_encoder_i2c(encoder)->i2c_client;
+	return (struct i2c_client *)to_encoder_slave(encoder)->bus_priv;
 }
 
-void nouveau_i2c_encoder_destroy(struct drm_encoder *encoder);
+/**
+ * drm_i2c_encoder_register - Register an I2C encoder driver
+ * @owner:	Module containing the driver.
+ * @driver:	Driver to be registered.
+ */
+static inline int drm_i2c_encoder_register(struct module *owner,
+					   struct drm_i2c_encoder_driver *driver)
+{
+	return i2c_register_driver(owner, &driver->i2c_driver);
+}
+
+/**
+ * drm_i2c_encoder_unregister - Unregister an I2C encoder driver
+ * @driver:	Driver to be unregistered.
+ */
+static inline void drm_i2c_encoder_unregister(struct drm_i2c_encoder_driver *driver)
+{
+	i2c_del_driver(&driver->i2c_driver);
+}
+
+void drm_i2c_encoder_destroy(struct drm_encoder *encoder);
+
 
 /*
  * Wrapper fxns which can be plugged in to drm_encoder_helper_funcs:
  */
 
-bool nouveau_i2c_encoder_mode_fixup(struct drm_encoder *encoder,
-				    const struct drm_display_mode *mode,
-				    struct drm_display_mode *adjusted_mode);
-enum drm_connector_status nouveau_i2c_encoder_detect(struct drm_encoder *encoder,
-						     struct drm_connector *connector);
-void nouveau_i2c_encoder_save(struct drm_encoder *encoder);
-void nouveau_i2c_encoder_restore(struct drm_encoder *encoder);
+void drm_i2c_encoder_dpms(struct drm_encoder *encoder, int mode);
+bool drm_i2c_encoder_mode_fixup(struct drm_encoder *encoder,
+		const struct drm_display_mode *mode,
+		struct drm_display_mode *adjusted_mode);
+void drm_i2c_encoder_prepare(struct drm_encoder *encoder);
+void drm_i2c_encoder_commit(struct drm_encoder *encoder);
+void drm_i2c_encoder_mode_set(struct drm_encoder *encoder,
+		struct drm_display_mode *mode,
+		struct drm_display_mode *adjusted_mode);
+enum drm_connector_status drm_i2c_encoder_detect(struct drm_encoder *encoder,
+	    struct drm_connector *connector);
+void drm_i2c_encoder_save(struct drm_encoder *encoder);
+void drm_i2c_encoder_restore(struct drm_encoder *encoder);
 
 
 #endif
